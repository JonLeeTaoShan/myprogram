#原理见：http://blog.csdn.net/xiaolewennofollow/article/details/46757657#order泰勒多项式次数 order=9;x = [-1:0.02:1];y = ((x.^2-1).*(x.^2-1).*(x.^2-1)+0.5).*sin(2*x);#r是0.6到1.4随机矩阵。r = mod(rand(1,101),0.8)+0.6;#ax,ay是x,y加入误差的矩阵xa = x.*r;ya = y.*r;#存储从0次到m次的所有冥方和bigMat=[];for j = 0:1:(2*order+1)  #fprintf('value of j: %d', j);  sum=0;  for i = 1:1:size(xa)(1,2)    sum+=xa(1,i)^j;  end  bigMat=[bigMat sum];end#计算线性方程组系数矩阵matA=[];for rowNum = 1:1:(order+1)  matA(rowNum,1:(order+1))=bigMat(1,rowNum:rowNum+order); endmatB=[];for i = 0:1:order  ty=0;  for k = 1:1:size(ya)(1,2);    ty+=ya(1,k)*(xa(1,k)^i);  end  #列矩阵  matB(i+1,1)=ty;endmatAA=linsolve(matA,matB);xxa = [-1:0.01:1];#画出拟合后的曲线yya=[];for i = 1:1:size(xxa)(1,2)  yy=0;  for j = 0:1:order #yy+=(xxa(1,i)^j)*matAA(j,1);    yy += (xxa(1,i)^j)*matAA(j+1,1);  end  yya=[yya yy];end#画图figure#原函数曲线（蓝色）plot(x,y);#保持图像hold on;#加入干扰生成的点（紫色）plot(xa,ya,'m.');#拟合曲线（绿色）plot(xxa,yya,'g');